{
  "name": "cards",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -16,
        -16
      ],
      "id": "cea6805a-0b6d-43a1-804d-7c5ace5bbdcc",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "content": "## Obtenção de cartas",
        "height": 258.0964713064308,
        "width": 903.9029040203084
      },
      "id": "1310d884-a5af-4616-a12a-4493f3293a19",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -80,
        -80
      ]
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "returnAll": true,
        "filter": {
          "folderId": {
            "__rl": true,
            "value": "1QNw3NdCrl9LLuh6pV2FSLVgMu-6SAVde",
            "mode": "list",
            "cachedResultName": "cartas em ingles",
            "cachedResultUrl": "https://drive.google.com/drive/folders/1QNw3NdCrl9LLuh6pV2FSLVgMu-6SAVde"
          }
        },
        "options": {
          "fields": [
            "webViewLink",
            "id",
            "name",
            "*"
          ]
        }
      },
      "id": "6810fda3-a89b-425e-b88a-d11f7816b64c",
      "name": "Encontra Cartas",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        192,
        -16
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "EZQEcbZc2fRD9p8C",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "resource": "image",
        "operation": "analyze",
        "modelId": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "GPT-4O"
        },
        "text": "Traduza o texto dessa imagem para o português.\nRetorne a resposta exclusivamente em CSV (sem bloco de código) usando vírgula como separador e incluindo uma linha de cabeçalho.\nUse exatamente as seguintes colunas na primeira linha: topic,aspect_name,aspect_description,point_id,point_question,point_description,background_color,text_color,section_dividers.\nCrie uma linha para cada ponto identificado repetindo as informações gerais quando necessário.\nSe uma informação não estiver disponível, deixe a célula vazia.\nGaranta que os valores que contêm vírgulas sejam envolvidos por aspas duplas e que aspas internas sejam duplicadas.",
        "imageUrls": "={{ $json.webContentLink }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        384,
        -16
      ],
      "id": "75ad4b2e-606c-4ba5-abb4-c4d3adaf3513",
      "name": "Analyze image",
      "credentials": {
        "openAiApi": {
          "id": "e24cqqnMWNr46eL0",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "const EXPECTED_HEADERS = [\n  'topic',\n  'aspect_name',\n  'aspect_description',\n  'point_id',\n  'point_question',\n  'point_description',\n  'background_color',\n  'text_color',\n  'section_dividers',\n];\n\nfunction normalizeHeader(line) {\n  return line\n    .replace(/^\\uFEFF/, '')\n    .split(',')\n    .map((part) => part.trim().toLowerCase())\n    .join(',');\n}\n\nfunction extractCsvBlock(input) {\n  if (typeof input !== 'string') {\n    return null;\n  }\n\n  const lines = input.split(/\\r?\\n/);\n  const normalizedExpected = normalizeHeader(EXPECTED_HEADERS.join(','));\n  const headerIndex = lines.findIndex((line) => normalizeHeader(line) === normalizedExpected);\n\n  if (headerIndex === -1) {\n    return null;\n  }\n\n  return lines.slice(headerIndex).join('\\n');\n}\n\nfunction parseCsvLine(line) {\n  const values = [];\n  let current = '';\n  let inQuotes = false;\n\n  for (let index = 0; index < line.length; index += 1) {\n    const char = line[index];\n\n    if (inQuotes) {\n      if (char === '\"') {\n        if (line[index + 1] === '\"') {\n          current += '\"';\n          index += 1;\n        } else {\n          inQuotes = false;\n        }\n      } else {\n        current += char;\n      }\n    } else if (char === '\"') {\n      inQuotes = true;\n    } else if (char === ',') {\n      values.push(current);\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n\n  values.push(current);\n\n  return values.map((value) => value.trim());\n}\n\nfunction parseCsvCandidate(candidate) {\n  const csvBlock = extractCsvBlock(candidate);\n\n  if (!csvBlock) {\n    return null;\n  }\n\n  const lines = csvBlock.split(/\\r?\\n/);\n\n  while (lines.length && !lines[0].trim()) {\n    lines.shift();\n  }\n\n  if (!lines.length) {\n    return null;\n  }\n\n  const parsedLines = [];\n  const headerLine = lines.shift().replace(/\\r$/, '');\n  const headers = parseCsvLine(headerLine);\n  const normalizedHeaders = headers.map((header) => header.trim().toLowerCase());\n  const expectedNormalized = EXPECTED_HEADERS.map((header) => header.toLowerCase());\n\n  if (\n    normalizedHeaders.length !== expectedNormalized.length ||\n    normalizedHeaders.some((value, index) => value !== expectedNormalized[index])\n  ) {\n    return null;\n  }\n\n  const rows = [];\n  parsedLines.push(headerLine);\n\n  for (const rawLine of lines) {\n    const cleanedLine = rawLine.replace(/\\r$/, '');\n\n    if (!cleanedLine.trim()) {\n      continue;\n    }\n\n    const values = parseCsvLine(cleanedLine);\n\n    if (values.length !== headers.length) {\n      break;\n    }\n\n    const entry = {};\n\n    for (let index = 0; index < EXPECTED_HEADERS.length; index += 1) {\n      const key = EXPECTED_HEADERS[index];\n      const value = values[index] ?? '';\n      entry[key] = typeof value === 'string' ? value.trim() : '';\n    }\n\n    rows.push(entry);\n    parsedLines.push(cleanedLine);\n  }\n\n  if (!rows.length) {\n    return null;\n  }\n\n  return {\n    rows,\n    rawCsv: parsedLines.join('\\n'),\n  };\n}\n\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json ?? {};\n  const candidates = [];\n\n  if (typeof data === 'string') {\n    candidates.push(data);\n  }\n\n  if (typeof data.text === 'string') {\n    candidates.push(data.text);\n  }\n\n  if (typeof data.result === 'string') {\n    candidates.push(data.result);\n  }\n\n  if (Array.isArray(data.data)) {\n    for (const entry of data.data) {\n      if (!entry) {\n        continue;\n      }\n\n      if (typeof entry === 'string') {\n        candidates.push(entry);\n        continue;\n      }\n\n      const content = entry.content ?? entry.message ?? entry.text;\n\n      if (typeof content === 'string') {\n        candidates.push(content);\n      } else if (Array.isArray(content)) {\n        for (const contentEntry of content) {\n          if (!contentEntry) {\n            continue;\n          }\n\n          if (typeof contentEntry === 'string') {\n            candidates.push(contentEntry);\n          } else if (typeof contentEntry.text === 'string') {\n            candidates.push(contentEntry.text);\n          }\n        }\n      }\n    }\n  } else if (typeof data.data === 'string') {\n    candidates.push(data.data);\n  }\n\n  if (Array.isArray(data.choices)) {\n    for (const choice of data.choices) {\n      if (!choice) {\n        continue;\n      }\n\n      if (typeof choice.text === 'string') {\n        candidates.push(choice.text);\n      }\n\n      const message = choice.message ?? {};\n\n      if (typeof message === 'string') {\n        candidates.push(message);\n      } else if (typeof message.content === 'string') {\n        candidates.push(message.content);\n      } else if (Array.isArray(message.content)) {\n        for (const entry of message.content) {\n          if (!entry) {\n            continue;\n          }\n\n          if (typeof entry === 'string') {\n            candidates.push(entry);\n          } else if (typeof entry.text === 'string') {\n            candidates.push(entry.text);\n          }\n        }\n      }\n    }\n  }\n\n  const uniqueCandidates = [...new Set(candidates.filter((candidate) => typeof candidate === 'string' && candidate.trim().length))];\n\n  let parsed;\n\n  for (const candidate of uniqueCandidates) {\n    const result = parseCsvCandidate(candidate);\n\n    if (result) {\n      parsed = result;\n      break;\n    }\n  }\n\n  if (!parsed) {\n    throw new Error('Não foi possível interpretar a resposta do modelo como CSV.');\n  }\n\n  results.push({ json: parsed });\n}\n\nreturn results;"
      },
      "id": "7390872e-e6bd-4d59-93fa-88da0655222c",
      "name": "Interpretar CSV",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        576,
        -16
      ]
    },
    {
      "parameters": {
        "functionCode": "const EXPECTED_HEADERS = [\n  'topic',\n  'aspect_name',\n  'aspect_description',\n  'point_id',\n  'point_question',\n  'point_description',\n  'background_color',\n  'text_color',\n  'section_dividers',\n];\n\nconst output = [];\n\nfor (const item of items) {\n  const rows = item.json?.rows;\n\n  if (!Array.isArray(rows) || !rows.length) {\n    continue;\n  }\n\n  for (const row of rows) {\n    const entry = {};\n\n    for (const header of EXPECTED_HEADERS) {\n      const value = row?.[header];\n      entry[header] = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n    }\n\n    output.push({ json: entry });\n  }\n}\n\nif (!output.length) {\n  throw new Error('Nenhuma linha CSV foi encontrada para registrar.');\n}\n\nreturn output;"
      },
      "id": "469118c7-051a-4332-b240-d0ac6295e1db",
      "name": "Preparar linhas",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        768,
        112
      ]
    },
    {
      "parameters": {
        "resource": "document",
        "operation": "create",
        "title": "={{ 'crads' + $now.toFormat('yyyyLLddHHmmss') }}"
      },
      "id": "fbd3a81d-b3f5-4f8d-a792-ffaeea9cadf8",
      "name": "Criar planilha",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [
        768,
        -128
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "TfqOT5rYq8z8E7Wc",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "resource": "sheet",
        "sheetId": "={{ $('Criar planilha').item.json.spreadsheetId }}",
        "options": {
          "valueInputMode": "RAW"
        },
        "columns": [
          "topic",
          "aspect_name",
          "aspect_description",
          "point_id",
          "point_question",
          "point_description",
          "background_color",
          "text_color",
          "section_dividers"
        ]
      },
      "id": "6f3aa757-7ae9-4427-afba-19aae4a830ad",
      "name": "Registrar dados",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [
        960,
        112
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "TfqOT5rYq8z8E7Wc",
          "name": "Google Sheets account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Encontra Cartas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Encontra Cartas": {
      "main": [
        [
          {
            "node": "Analyze image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze image": {
      "main": [
        [
          {
            "node": "Interpretar CSV",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar linhas": {
      "main": [
        [
          {
            "node": "Registrar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Criar planilha": {
      "main": [
        [
          {
            "node": "Registrar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpretar CSV": {
      "main": [
        [
          {
            "node": "Criar planilha",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar linhas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "3ec2323b-6053-4f9d-8be5-300525b6bdec",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "9f80713bf772ccc2c93dc92bf6168d73ec5f1400b4f905df9368f7195b1135bb"
  },
  "id": "85Knexd4LJtR7QUz",
  "tags": []
}
